# ============================================================================
# PhaserAI CI/CD Pipeline
# ============================================================================
#
# This GitHub Actions workflow provides comprehensive CI/CD for the PhaserAI
# conlang application, including frontend, backend, and infrastructure.
#
# PIPELINE STAGES:
# 1. Code Quality & Security - Linting, formatting, security scans
# 2. Build & Test - Frontend build, Lambda layer build, CDK synthesis
# 3. Infrastructure Validation - CDK diff, security checks
# 4. Deployment (future) - ECR push, CDK deploy
#
# TRIGGERS:
# - Push to main branch (full pipeline)
# - Pull requests (build and test only)
# - Manual dispatch (with deployment options)
#
# ENVIRONMENTS:
# - Development: Auto-deploy on main branch
# - Staging: Manual approval required
# - Production: Manual approval + additional checks
#
# ============================================================================

name: PhaserAI CI/CD Pipeline

on:
  push:
    branches: [main, develop, master]
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
  
  pull_request:
    branches: [main, develop, master]
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
  
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production
      deploy_infrastructure:
        description: 'Deploy infrastructure changes'
        required: false
        default: false
        type: boolean
      run_migrations:
        description: 'Run database migrations'
        required: false
        default: false
        type: boolean

# Global environment variables
env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'
  PNPM_VERSION: '8'
  AWS_REGION: 'us-east-1'

# Concurrency control - cancel in-progress runs for the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # JOB 1: CODE QUALITY & SECURITY
  # ============================================================================
  code-quality:
    name: Code Quality & Security
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better analysis
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Setup pnpm cache
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install Frontend Dependencies
        run: |
          echo "üì¶ Installing frontend dependencies..."
          
          # Try frozen lockfile first (preferred for CI)
          if pnpm install --frozen-lockfile; then
            echo "‚úÖ Frontend dependencies installed with frozen lockfile"
          else
            echo "‚ö†Ô∏è Frozen lockfile failed - pnpm-lock.yaml may be outdated"
            echo "üîÑ Attempting to install and update lockfile..."
            
            # Install without frozen lockfile
            pnpm install
            
            echo "üìã Lock file has been updated. Consider committing the changes:"
            echo "  git add pnpm-lock.yaml"
            echo "  git commit -m 'chore: update pnpm-lock.yaml'"
            
            # In CI, we'll continue but warn about the mismatch
            echo "‚ö†Ô∏è WARNING: pnpm-lock.yaml was out of sync with package.json"
          fi
      
      - name: Install Infrastructure Dependencies
        working-directory: ./infra
        run: npm ci
      
      - name: Lint Frontend Code
        run: |
          echo "üîç Running ESLint checks..."
          
          # Verify ESLint config exists
          if [ ! -f "eslint.config.js" ]; then
            echo "‚ùå eslint.config.js not found"
            exit 1
          fi
          
          # Run ESLint
          pnpm run lint
          echo "‚úÖ Frontend linting completed"
        continue-on-error: true  # Don't fail build, but report issues
      
      - name: Check Code Formatting
        run: |
          echo "üé® Checking code formatting..."
          if pnpm run format:check; then
            echo "‚úÖ Code formatting check completed"
          else
            echo "‚ö†Ô∏è Code formatting issues found"
            echo "üí° Run 'pnpm run format' to fix formatting issues"
            # Don't fail the build, just warn
          fi
        continue-on-error: true
      
      - name: Lint Infrastructure Code
        working-directory: ./infra
        run: npm run lint
        continue-on-error: true
      
      - name: Check Code Formatting
        run: |
          echo "üé® Checking code formatting..."
          if pnpm run format:check; then
            echo "‚úÖ Code formatting check completed"
          else
            echo "‚ö†Ô∏è Code formatting issues found"
            echo "üí° Run 'pnpm run format' to fix formatting issues"
            # Don't fail the build, just warn
          fi
        continue-on-error: true
      
      - name: TypeScript Type Check
        run: |
          pnpm run type-check
          echo "‚úÖ TypeScript type checking completed"
      
      - name: Security Audit - Frontend
        run: |
          pnpm audit --audit-level moderate
          echo "‚úÖ Frontend security audit completed"
        continue-on-error: true
      
      - name: Security Audit - Infrastructure
        working-directory: ./infra
        run: |
          npm audit --audit-level moderate
          echo "‚úÖ Infrastructure security audit completed"
        continue-on-error: true
      
      # Upload results for later jobs
      - name: Upload Lint Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: lint-results
          path: |
            eslint-report.json
            infra/eslint-report.json
          retention-days: 7

  # ============================================================================
  # JOB 2: BUILD & TEST
  # ============================================================================
  build-test:
    name: Build & Test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: code-quality
    
    strategy:
      matrix:
        component: [frontend, docker, lambda-layers, infrastructure]
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
      
      - name: Get pnpm store directory
        if: matrix.component == 'frontend' || matrix.component == 'docker'
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Setup pnpm cache
        if: matrix.component == 'frontend' || matrix.component == 'docker'
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Set up Docker Buildx
        if: matrix.component == 'docker'
        uses: docker/setup-buildx-action@v3
      
      # Frontend Build
      - name: Build Frontend
        if: matrix.component == 'frontend'
        run: |
          echo "üèóÔ∏è Building frontend application..."
          
          # Install dependencies with fallback
          if pnpm install --frozen-lockfile; then
            echo "‚úÖ Dependencies installed with frozen lockfile"
          else
            echo "‚ö†Ô∏è Frozen lockfile failed - updating lockfile and continuing..."
            pnpm install
          fi
          
          pnpm run build
          echo "‚úÖ Frontend build completed"
          
          # Verify build output
          if [ ! -d "dist" ]; then
            echo "‚ùå Build failed - dist directory not found"
            exit 1
          fi
          
          echo "üìä Build size analysis:"
          du -sh dist/
          ls -la dist/
      
      # Docker Build
      - name: Build Docker Images
        if: matrix.component == 'docker'
        run: |
          echo "üê≥ Building Docker images..."
          
          # Build development image
          echo "Building development image..."
          docker build -f Dockerfile.dev -t phaserai-dev:latest \
            --build-arg VITE_SUPABASE_URL=https://dummy-dev-url.supabase.co \
            --build-arg VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.dummy-dev-key \
            .
          
          # Build production image
          echo "Building production image..."
          docker build -f Dockerfile -t phaserai:latest \
            --build-arg VITE_SUPABASE_URL=https://dummy-prod-url.supabase.co \
            --build-arg VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.dummy-prod-key \
            .
          
          echo "‚úÖ Docker images built successfully"
          
          # Show image information
          echo "üìä Docker image analysis:"
          docker images | grep phaserai
          
          # Test development image
          echo "üß™ Testing development image..."
          docker run --rm -d --name phaserai-dev-test -p 5173:5173 phaserai-dev:latest &
          sleep 15
          echo "Development container logs:"
          docker logs phaserai-dev-test | head -10
          docker stop phaserai-dev-test || true
          
          # Test production image
          echo "üß™ Testing production image..."
          docker run --rm -d --name phaserai-prod-test -p 8080:80 phaserai:latest &
          sleep 10
          
          # Health check
          if curl -f http://localhost:8080 > /dev/null 2>&1; then
            echo "‚úÖ Production image health check passed"
          else
            echo "‚ö†Ô∏è Production image health check failed (may be expected in CI)"
            docker logs phaserai-prod-test | head -10
          fi
          
          docker stop phaserai-prod-test || true
          
          # Save images for potential upload
          echo "üíæ Saving Docker images..."
          docker save phaserai:latest | gzip > phaserai-latest.tar.gz
          docker save phaserai-dev:latest | gzip > phaserai-dev-latest.tar.gz
          
          echo "üì¶ Image sizes:"
          ls -lh *.tar.gz
      
      # Lambda Layers Build
      - name: Build Lambda Layers
        if: matrix.component == 'lambda-layers'
        run: |
          echo "üêç Building Lambda layers..."
          
          # Build psycopg2 layer
          cd infra/lambda-layers/psycopg2
          chmod +x build-layer.sh verify-deployment.sh
          
          echo "Building psycopg2 layer..."
          ./build-layer.sh
          
          echo "Verifying layer deployment readiness..."
          ./verify-deployment.sh
          
          echo "‚úÖ Lambda layers build completed"
      
      # Infrastructure Build & Synthesis
      - name: Build Infrastructure
        if: matrix.component == 'infrastructure'
        run: |
          echo "üèóÔ∏è Building and synthesizing CDK infrastructure..."
          
          cd infra
          npm ci
          
          # CDK synthesis (validates all stacks)
          echo "Synthesizing CDK stacks..."
          npx cdk synth --all --quiet
          
          echo "‚úÖ Infrastructure synthesis completed"
          
          # List generated CloudFormation templates
          echo "üìã Generated CloudFormation templates:"
          find cdk.out -name "*.template.json" -exec basename {} \;
      
      # Upload build artifacts
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.component }}
          path: |
            dist/
            infra/cdk.out/
            infra/lambda-layers/psycopg2/python/
            *.tar.gz
          retention-days: 7

  # ============================================================================
  # JOB 2.5: PUSH DOCKER IMAGES TO ECR
  # ============================================================================
  push-to-ecr:
    name: Push Docker Images to ECR
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: build-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
    
    permissions:
      id-token: write   # Required for OIDC token requests
      contents: read    # Required for actions/checkout
    
    steps:
      - name: Debug Push Conditions
        run: |
          echo "üîç Debugging ECR push conditions..."
          echo "Event name: ${{ github.event_name }}"
          echo "Git ref: ${{ github.ref }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Is main branch: ${{ github.ref == 'refs/heads/main' }}"
          echo "Is master branch: ${{ github.ref == 'refs/heads/master' }}"
          echo "Is develop branch: ${{ github.ref == 'refs/heads/develop' }}"
          echo "Is workflow dispatch: ${{ github.event_name == 'workflow_dispatch' }}"
          echo ""
          echo "‚úÖ ECR push job is running - conditions met!"
      
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Option A: Using IAM User (requires AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY secrets)
          # aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          # aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          # aws-region: ${{ env.AWS_REGION }}
          # Option B: Using IAM Role with OIDC (more secure, comment out above and uncomment below)
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-ECR-Push
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get ECR Repository URI
        id: ecr-info
        run: |
          echo "üîç Getting ECR repository information..."
          
          # Construct repository URI directly (more reliable than CloudFormation)
          AWS_ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}"
          AWS_REGION="${{ env.AWS_REGION }}"
          REPO_NAME="phaserai"
          
          REPO_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPO_NAME}"
          
          echo "‚úÖ ECR repository URI: $REPO_URI"
          echo "repository-uri=$REPO_URI" >> $GITHUB_OUTPUT
          echo "repository-name=$REPO_NAME" >> $GITHUB_OUTPUT
          
          # Verify repository exists
          if aws ecr describe-repositories --repository-names "$REPO_NAME" --region "$AWS_REGION" &> /dev/null; then
            echo "‚úÖ ECR repository exists and is accessible"
          else
            echo "‚ùå ECR repository not found or not accessible"
            echo "üí° Ensure the ECR stack is deployed: ./scripts/deploy-ecr.sh"
            exit 1
          fi
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Setup pnpm cache
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.ecr-info.outputs.repository-uri }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}
          labels: |
            org.opencontainers.image.title=PhaserAI
            org.opencontainers.image.description=Conlang creation and management application
            org.opencontainers.image.vendor=PhaserAI
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
      
      - name: Build and Push Production Image to ECR
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL || 'https://dummy-url.supabase.co' }}
            VITE_SUPABASE_ANON_KEY=${{ secrets.VITE_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.dummy-key' }}
          cache-from: type=gha,scope=prod-ecr
          cache-to: type=gha,mode=max,scope=prod-ecr
      
      - name: Build and Push Development Image to ECR
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.dev
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ steps.ecr-info.outputs.repository-uri }}:dev
            ${{ steps.ecr-info.outputs.repository-uri }}:dev-${{ github.sha }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL || 'https://dummy-url.supabase.co' }}
            VITE_SUPABASE_ANON_KEY=${{ secrets.VITE_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.dummy-key' }}
          cache-from: type=gha,scope=dev-ecr
          cache-to: type=gha,mode=max,scope=dev-ecr
      
      - name: Scan Images for Vulnerabilities
        run: |
          echo "üîç Scanning images for vulnerabilities..."
          
          # Get repository name
          REPO_NAME="${{ steps.ecr-info.outputs.repository-name }}"
          
          # Scan production image
          echo "Scanning production image..."
          aws ecr start-image-scan \
            --repository-name "$REPO_NAME" \
            --image-id imageTag=latest \
            --region ${{ env.AWS_REGION }} || echo "Scan already in progress or failed"
          
          # Scan development image
          echo "Scanning development image..."
          aws ecr start-image-scan \
            --repository-name "$REPO_NAME" \
            --image-id imageTag=dev \
            --region ${{ env.AWS_REGION }} || echo "Scan already in progress or failed"
          
          echo "‚úÖ Vulnerability scans initiated"
          echo "üí° View scan results in AWS ECR console"
      
      - name: Output Image Information
        run: |
          echo "üì¶ Docker Images Pushed to ECR"
          echo "=============================="
          echo "Registry: ${{ steps.login-ecr.outputs.registry }}"
          echo "Repository: ${{ steps.ecr-info.outputs.repository-uri }}"
          echo ""
          echo "Production Images:"
          echo "${{ steps.meta.outputs.tags }}" | while read -r tag; do
            echo "  - $tag"
          done
          echo ""
          echo "Development Images:"
          echo "  - ${{ steps.ecr-info.outputs.repository-uri }}:dev"
          echo "  - ${{ steps.ecr-info.outputs.repository-uri }}:dev-${{ github.sha }}"
          echo ""
          echo "Image Digest: ${{ steps.meta.outputs.digest }}"
          echo ""
          echo "üîó View in AWS Console:"
          echo "https://console.aws.amazon.com/ecr/repositories/private/${{ secrets.AWS_ACCOUNT_ID }}/${{ steps.ecr-info.outputs.repository-name }}?region=${{ env.AWS_REGION }}"

  # ============================================================================
  # JOB 3: INFRASTRUCTURE VALIDATION
  # ============================================================================
  infrastructure-validation:
    name: Infrastructure Validation
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: build-test
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Download Infrastructure Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-infrastructure
          path: ./
      
      - name: Install CDK Dependencies
        working-directory: ./infra
        run: npm ci
      
      - name: CDK Security Check
        working-directory: ./infra
        run: |
          echo "üîí Running CDK security validation..."
          
          # Ensure CDK synthesis works
          echo "Running CDK synthesis for security analysis..."
          if npm run synth > cdk-synth.log 2>&1; then
            echo "‚úÖ CDK synthesis completed successfully"
          else
            echo "‚ùå CDK synthesis failed"
            cat cdk-synth.log
            exit 1
          fi
          
          # Check for common security issues
          echo "Checking for hardcoded secrets..."
          if grep -r "password\|secret\|key" cdk.out/ --include="*.json" | grep -v "Ref\|GetAtt\|Parameter" | head -5; then
            echo "‚ö†Ô∏è Potential hardcoded secrets found - review above results"
          else
            echo "‚úÖ No hardcoded secrets detected"
          fi
          
          echo "Checking for public access..."
          if grep -r "0.0.0.0/0" cdk.out/ --include="*.json" | head -5; then
            echo "‚ö†Ô∏è Public access detected - review security groups above"
          else
            echo "‚úÖ No unrestricted public access found"
          fi
          
          echo "Checking for unencrypted resources..."
          if grep -r "Encrypted.*false" cdk.out/ --include="*.json" | head -5; then
            echo "‚ö†Ô∏è Unencrypted resources found - review above results"
          else
            echo "‚úÖ No unencrypted resources detected"
          fi
          
          echo "‚úÖ CDK security analysis completed"
      
      - name: CDK Diff Analysis
        working-directory: ./infra
        run: |
          echo "üìä Analyzing infrastructure changes..."
          
          # This would normally compare against deployed stack
          # For now, we'll validate the templates
          echo "Validating CloudFormation templates..."
          
          for template in cdk.out/*.template.json; do
            if [ -f "$template" ]; then
              echo "Validating $(basename "$template")..."
              # Basic JSON validation
              python3 -m json.tool "$template" > /dev/null
              echo "‚úÖ $(basename "$template") is valid"
            fi
          done
      
      - name: Cost Estimation
        working-directory: ./infra
        run: |
          echo "üí∞ Estimating infrastructure costs..."
          
          # Count resources by type for rough cost estimation
          echo "Resource summary:"
          grep -r "Type.*AWS::" cdk.out/ --include="*.json" | \
            sed 's/.*"Type": "//; s/".*//' | \
            sort | uniq -c | \
            sort -nr
          
          echo "üí° Review AWS Pricing Calculator for detailed cost estimates"

  # ============================================================================
  # JOB 4: INTEGRATION TESTS (Future)
  # ============================================================================
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: build-test
    if: false  # Disabled for now - enable when tests are ready
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: phaserai_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Test Environment
        run: |
          echo "üß™ Setting up integration test environment..."
          # Future: Setup test database, mock services, etc.
      
      - name: Run Integration Tests
        run: |
          echo "üß™ Running integration tests..."
          # Future: Run API tests, database migration tests, etc.

  # ============================================================================
  # JOB 5: DEPLOYMENT PREPARATION
  # ============================================================================
  deployment-prep:
    name: Deployment Preparation
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [build-test, infrastructure-validation, push-to-ecr]
    if: github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    
    outputs:
      should-deploy: ${{ steps.deploy-check.outputs.should-deploy }}
      environment: ${{ steps.deploy-check.outputs.environment }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Determine Deployment Strategy
        id: deploy-check
        run: |
          echo "üöÄ Determining deployment strategy..."
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Manual deployment triggered"
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "Auto-deployment to development"
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "environment=development" >> $GITHUB_OUTPUT
          else
            echo "No deployment needed"
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "environment=none" >> $GITHUB_OUTPUT
          fi
      
      - name: Download All Artifacts
        if: steps.deploy-check.outputs.should-deploy == 'true'
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
      
      - name: Prepare Deployment Package
        if: steps.deploy-check.outputs.should-deploy == 'true'
        run: |
          echo "üì¶ Preparing deployment package..."
          
          # Create deployment directory
          mkdir -p deployment
          
          # Copy frontend build
          if [ -d "artifacts/build-frontend/dist" ]; then
            cp -r artifacts/build-frontend/dist deployment/frontend
            echo "‚úÖ Frontend assets prepared"
          fi
          
          # Copy infrastructure
          if [ -d "artifacts/build-infrastructure/infra/cdk.out" ]; then
            cp -r artifacts/build-infrastructure/infra/cdk.out deployment/infrastructure
            echo "‚úÖ Infrastructure templates prepared"
          fi
          
          # Copy Lambda layers
          if [ -d "artifacts/build-lambda-layers/infra/lambda-layers" ]; then
            cp -r artifacts/build-lambda-layers/infra/lambda-layers deployment/layers
            echo "‚úÖ Lambda layers prepared"
          fi
          
          echo "üìä Deployment package size:"
          du -sh deployment/
      
      - name: Upload Deployment Package
        if: steps.deploy-check.outputs.should-deploy == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package
          path: deployment/
          retention-days: 30

  # ============================================================================
  # JOB 6: DEPLOYMENT (Future - ECR & CDK Deploy)
  # ============================================================================
  deploy:
    name: Deploy to ${{ needs.deployment-prep.outputs.environment }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: deployment-prep
    if: needs.deployment-prep.outputs.should-deploy == 'true' && false  # Disabled for now
    
    environment:
      name: ${{ needs.deployment-prep.outputs.environment }}
      url: ${{ steps.deploy.outputs.app-url }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Download Deployment Package
        uses: actions/download-artifact@v4
        with:
          name: deployment-package
          path: ./deployment
      
      - name: Deploy Infrastructure
        id: deploy
        run: |
          echo "üöÄ Deploying to ${{ needs.deployment-prep.outputs.environment }}..."
          
          # Future: CDK deploy commands
          # cd infra
          # npx cdk deploy --all --require-approval never
          
          echo "‚úÖ Deployment completed"
          echo "app-url=https://example.com" >> $GITHUB_OUTPUT

  # ============================================================================
  # JOB 7: POST-DEPLOYMENT VALIDATION (Future)
  # ============================================================================
  post-deployment:
    name: Post-Deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: deploy
    if: false  # Disabled for now
    
    steps:
      - name: Health Check
        run: |
          echo "üè• Running post-deployment health checks..."
          # Future: API health checks, database connectivity, etc.
      
      - name: Smoke Tests
        run: |
          echo "üí® Running smoke tests..."
          # Future: Basic functionality tests

  # ============================================================================
  # JOB 8: NOTIFICATION & CLEANUP
  # ============================================================================
  notify:
    name: Notification & Cleanup
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [code-quality, build-test, infrastructure-validation, deployment-prep, push-to-ecr]
    if: always()
    
    steps:
      - name: Pipeline Summary
        run: |
          echo "üìä Pipeline Summary"
          echo "=================="
          echo "Code Quality: ${{ needs.code-quality.result }}"
          echo "Build & Test: ${{ needs.build-test.result }}"
          echo "Infrastructure: ${{ needs.infrastructure-validation.result }}"
          echo "ECR Push: ${{ needs.push-to-ecr.result }}"
          echo "Deployment Prep: ${{ needs.deployment-prep.result }}"
          
          if [ "${{ needs.code-quality.result }}" = "success" ] && \
             [ "${{ needs.build-test.result }}" = "success" ]; then
            echo "‚úÖ Pipeline completed successfully"
          else
            echo "‚ùå Pipeline had failures"
          fi
      
      - name: Cleanup Artifacts
        if: github.event_name == 'pull_request'
        run: |
          echo "üßπ Cleaning up PR artifacts..."
          # Artifacts are automatically cleaned up by retention policy